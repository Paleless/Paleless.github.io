---
layout: post
title: 编程与抽象
---

**编程，是将现实世界中的事物、行为进行抽象化，从而达到减少人力、提升艺术的表现力等多种目的一种方式。**  
<br />

编程语言作为最基础、通用的一种抽象方式，可以用来构造更高层的抽象。  
基于编程语言，构建函数库、框架、更高级的编程语言作为更高层抽象。  
基于函数库和框架，构建基础服务、基础设施、RPC服务作为更高层抽象。  
基于基础服务，构建高级工具并构建通用指令对外提供，作为更高层抽象。  
<br />

这些通用指令往往非常通用，不需要使用者理解其内部实现，命名能够准确描述其操作（当然首先要求使用者熟悉工具的基础使用思想）。  
比如：  
  - git 作为通用版本管理，提供 git add、git commit 等基础指令来进行版本控制。  

<br />
  
在基础指令之上，还可以再构建抽象，如果只是单纯暴露当前指令或者不涉及复杂设计的话，那么这可能是最后一层抽象。  
这一层抽象，往往表现为用户界面，或者实体的某些按钮，用户的网页、手机的APP、最为简单的计算器，都是其表现形式。 
<br />
<br />
  
如果需要构建比较复杂的抽象，那么可以需要根据复杂程度，进行再抽象分层。  
举个最为简单的例子：  
  - 如果有个简单的计算器指令，只提供 +、- 两种操作，如果不计较的话，已经可以提供界面层抽象了。  
  但是可以使用 +、-, 构建 *、/ 等更多操作，并在其基础上再进行界面构建。  
<br >
  
不难理解，**编程也是不断使用基础抽象，不断构建更高级抽象的过程**。
<br />
<br />
同时也不难理解，**前端**、**后端**等多数开发者都能在这些抽象层中找到自己的位置，比如前端抽象界面层，后端抽象服务层。

接下来会基于此，简述抽象编程的一些想法于思考。  
<br/>
<br/>

## 理解抽象
要解释清楚抽象并不容易，从常规概念来说：
> “抽象是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征的过程。”

基于个人理解认为，抽象即是弱化其它部分，强调需要关注的核心点，简化为具体概念，方便理解和使用。
比如：
  - 对于艺术家来说，一个足球作为一个圆形，更容易在画板上进行绘制，而无需考虑它的总量、大小等因素
  - 对于程序员来说，add 函数接受两个数字返回其和，其内部是如何运转、数据如何存储、内部表示是用二进制还是其它方式均无关紧要，至少在你使用它的时候
<br/>
<br/>
<br/>

## 抽象的意义
**抽象的目的是为了降低复杂度。**
<br/>
<br/>
如果不进行抽象，你在尝试做某件事情的时候会不得不被迫去了解很多无关紧要的部分。  
比如，当你尝试在语言中实现add，却发现自己要关注的不是是a和b如何相加，还要考虑到如何在不同的进制、补码之间转换。  

又比如，当你尝试在表单中增加一个输入框，由于没有现成的input组件，你在添加此输入框的同时除了输入框的值外还需要关注其focus、unfoucs事件，对应事件下的样式变化，这些毫无疑问多会增加很多状态。  
<br/>
更深入的了解抽象，理解其目的，才能更好的使用它。
<br/>
<br/>
<br/>

## 计算机与编程中的抽象
理解了抽象后，就不难说明在计算机领域各种抽象的概念了。

比如：
- TCP/IP 四层模型、OSI七层模型，分层的目的是为了更好的构建和理解。
- 进程、线程、协程，这是都是抽象出的概念模型
- 变量、函数、类、结构体是编程语言抽象出的常规概念
- +、-、*、/，这些是计算的基础抽象概念
- 对象、继承、克隆、设计模式，这些是面向对象的抽象概念
- compose、identigy、Maybe、Monad、Functor，这些是函数式的抽象概念
- 模块、service、component 这些是基于 mvvm 进行开发需要理解的抽象概念
- binding、vdom、observer、template-parser，这些是 vue 源码设计过程中的抽象概念
<br/>
<br/>

本文开头的例子可以看出，抽象可以基于另一层去构建新的更高级、更通用的抽象
上述例子也可以看出，抽象之间可以组合，比如：
- 使用编程语言、函数式编程范式、模块化、vue去构建前端
- 使用编程语言、service、模块化等抽象概念去构建后端

**编程即是构建抽象的过程**
<br/>
<br/>
<br/>

## 如何构建抽象
如何更好的去构建抽象，可以说是编程方面一直在研究的问题。
<br/>
<br/>

### 简单的分层
首先，多数时候，我们总是基于另一层抽象，组合其余通用抽象概念来构建更高级抽象。  
比如，后端提供 API，前端使用 html/css/javascript 来构建UI层。

这个时候，对于需要理解的人来说，往往只需要关注两层，即 **前端**、**后端**。
<br/>
<br/>

### 抽象的展开/合并
**只关注两层并不意味这只有两层。**  
这里的分层是为了便于理解，但是分层的核心木的是为了降低复杂度，如果某一层过于复杂，完全可以再分层。  
>说个简单的个人理解：很久之前没有前后端之分，前后端分离是为了降低复杂度。  
>如果后续前端继续复杂化，可能会继续拆分，现在国外就有人再吵要拆分UI/逻辑层（笑~）  

将vue、模块化、组件化引入前端，基于此在进行抽象化设计。  
常见的应用，一般只有两层：
- AUTH权限校验层，一般放在路由拦截、axios拦截中，处理用户权限
- 页面层，展示页面

针对不同类型、目的应用，完全可以再分层，复杂的表单可以增加回填层，编辑器添加统一指定处理层。  
> 如果说database除去可以持久化保存数据，而只关注其对于数据的组织能力的话，前端未来一定会出现这种东西的应用。

<br/>
<br/>
以上可以发现，基于当前复杂度、应用类型来进行层的拆分管理，在不同情况的合理的进行抽象层的合并，从而构建更好的抽象。
<br/>
<br/>
<br/>

### 学习其它系统的抽象
抽象毫无疑问是通用概念，你能在编程中使用，能在生活中使用，能在艺术中使用。
> 如果你有空的话 [哥德尔、艾舍尔、巴赫](https://book.douban.com/subject/1291204/), 应该是有空时候该读的一本书  
> [the art of programming](https://www.youtube.com/watch?v=6avJHaC3C2U&t=157s) 这个视频的 43：34s处，展示了如何将代码转化为乐谱，这似乎并不能提升对抽象的理解，但这证明了万物本质相通，不过是不同事物在各个抽象层中不同形式的同构

或许，你在日常编码中不需要深入的深入的了解操作系统的设计、函数式编程、数据库的设计，因为你不会用到。   
作为前端，如果你使用vue，没人强迫你去了解react的设计，因为你并不适用它。  
作为后端，你可以不了解前端设计，因为你专注api设计。
<br/>
<br/>
但是，编程本质都是在构建抽象，处理抽象分层，了解操作系统是如何拆分各个模块、如何组织，计算机软硬件之间如何分离控制，如何管理公共状态，这些技巧是通用的，而且应该不只是针对编程。  
同理，建筑学、数学、范畴论等等领域，都能看到类似的东西。  

<br/>
你应该从生活从学习编程，并将编程应用于生活。
<br/>
<br/>
<br/>

### 为什么要了解底层抽象
除了学习其它系统的抽象技巧外，还有另外一个原因使得你必须去了解其它系统，即优化。

<br/>
可读性和性能总得有舍有得，好多谈及可读性和优化的书籍中总有类似的表达。
<br/>

作为前端，如果你使用vue构建应用，在不了解virtual-dom、diff、observer的情况下，完全可以进行应用构建。
处理页面渲染，不需要了解dom树的渲染，也可以写代码。

但是作为开发者，你不得不处理性能优化问题，**这类问题使得你必须要去了解底层实现**。

你可以使用递归来达到更声明式、简单的代码表达，但是while、for更快，也更稳定。
你可以使用 concat 来拼接数组，但是 push 更快。
你可以使用 delete 删除属性，但是 soemthing.key = undefined更快。
你会发现浏览器内存不断增加，但是不了解detched Dom, 可能很难确定到底是那儿发生了内存泄露。
不实用reqestAnimationFrame，你会发现你的动画总是不流畅。

<br/>
这些问题使得你必须去学习其它工具的底层抽象，了解其工作原理，搞清楚它的哪一个操作更快。

但是，**可读性和性能总得有舍有得**

<br/>
<br/>

## 如何利用代码实现抽象
说了这么多，那么到底如何做？  
一般来说，这得看你使用的工具，这里只举一个简单的例子。

<br/>
使用 JavaScript，我将 function 作为构建逻辑的基础单元

```javascript
function add(a, b) {
  return a + b;
}
```

可以看出，我提供了一个add，使用者可以用它获得a、b的结果。
> add 很简单，但记住这只是个例子

但是我并不希望所有人能使用它，我只希望有权限的人才能使用这个函数。
```javascript
function add(a, b) {
  const user = sessionStorage.getItem('currentUser');
  if (AUTHED_USERS.includes(user)) {
    return a + b;
  }
  throw new Error("you dont have auth!!!");
}
```